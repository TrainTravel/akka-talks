<!DOCTYPE html>
<html>
<head>
    <title>Awesome Presentation</title>
    <meta charset="utf-8">
    <style>
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

        body {
            font-family: 'Droid Serif', 'Helvetica';
        }

        h1, h2, h3 {
            font-family: 'Yanone Kaffeesatz', 'Gill Sans';
            font-weight: normal;
        }

        .remark-code, .remark-inline-code {
            font-family: 'Ubuntu Mono', 'Consolas', 'Courier New';
        }
    </style>
</head>
<body>
<textarea id="source">

```tut:invisible
import com.datastax.driver.core.{ResultSet, Session}
import com.typesafe.scalalogging.LazyLogging
import info.batey.akka.http.Domain.{Event, User, UserId}
import info.batey.akka.http._

import scala.collection.JavaConverters._
import scala.concurrent.{ExecutionContext, Future}
import info.batey.akka.http.DataAccess.{ cluster, session }
import scala.concurrent.ExecutionContext.Implicits.global

import info.batey.sync.WebFramework._
import info.batey.sync.SyncWebFramework._
import akka.http.scaladsl.model.{ContentTypes, HttpEntity, StatusCodes}
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.server._
import akka.stream.ActorMaterializer
import spray.json._

```

class: center, middle

# Scalable, responsive, back pressured services (with Akka)

Christopher Batey

â€¢ `@chbatey`

???
- notes here

---

# About me

* Christopher Batey
* Work @ Lightbend on the Akka team
    * Akka
    * Akka-streams
    * Akka-http
    * Reactive-kafka
    * Akka persistence for Apache Cassandra
    * Alpakka

???
- Notes

---

class: center, middle

# Responsive
# Scalable

???
- Notes

---

class: center, middle

# Asynchronous
# Back pressured

???
- Notes

---
# Goals

* High level
  * What does async give us?
  * What does flow control give us?
* Concrete tech
  * Flow control with Akka streams

---
# Use case
* HTTP Service, endpoints for:
  * User information from database
  * Sending data to another service
  * Getting user activity over a large time span

* Requirements
  * Respond in a timely manner, even if it is a failure
  * Don't do any unnecessary work
???
-

---
class: center, middle
# Responsive

???
- Because reasons


---
# Responsiveness
* Control over when your application response
  * Queues and buffers
* Dependencies

???
- Uh huh

---
class: center, middle
# Execution models

???
- Single threaded
- Thread per request
- Thread per core without blocking IO
- How to get this wrong even with the right tools


---
# Thread per request


```tut:silent
def post(request: HttpRequest): HttpResponse = {
  // do something very important
  ???
}
```

???
- Hystrix

---
# Thread per request

```tut:silent
def post(request: HttpRequest): HttpResponse = {
   val userId = request.getQueryParam("userId")
   val user: User = getUserFromDatabase(userId)

   ExternalService.sendPresentToUser(user)

   HttpResponse(200)
 }
```

???
- Bad mmkay
---

# Thread per request

```tut:silent
def post(request: HttpRequest): HttpResponse = {
   // nice and quick
   val userId = request.getQueryParam("userId")
   // 5 millis to 10 seconds?
   val user: User = getUserFromDatabase(userId)

   // 5 milliss to 10 seconds?
   ExternalService.sendPresentToUser(user)

   HttpResponse(200)
 }
```

???
- Socket read timeouts??
- Link to prove it talk next
- Pros: very simple programming model
- "back pressure" via max number of threads
---

# Demonstrating this

```
http://skillsmatter.com/skillscasts/6520-think-your-software-is-fault-tolerant-prove-it
```

???
- go try it out
---
# Async


```tut:silent
def request(request: HttpRequest): Future[HttpResponse] = ???
```

* Can have timeout independent of calls to our dependencies
* No thread is being used if we're waiting on IO
* Works well for small responses that are ready to go

???
- TODO


---
# Async


```tut:silent
def request(request: HttpRequest): Future[HttpResponse] =
  for {
    user <- lookupUser(request.getQueryParam("userId"))
    _ <- AsyncExternalService.sendPresentToUser(user)
  } yield HttpResponse(200)
```

???
-

---
# Akka HTTP

```tut:silent
path("user" / Segment) { name =>
  get {
    val user: Future[Option[User]] = DataAccess.lookupUser(name)
    onComplete(user) {
      case Success(Some(u)) => complete(u)
      case Success(None)    => complete(NotFound)
      case Failure(t)       => complete(InternalServerError, t.getMessage)
    }
}
```


---
# Database

```scala
val session = ... // From the Cassandra driver
```

```tut:silent
def lookupUser(userId: UserId): Future[Option[User]] = {
   session.executeAsync("select * from users where user_id = ?", userId).asScala
     .map((rs: ResultSet) => Option(rs.one())
     .map(row => User(
         row.getString("user_id"),
         row.getString("user_name"),
         row.getInt("age"))))
}
```

???
- see

---
# Akka HTTP


```tut:silent
path("user" / Segment) { name =>
  get {
    withRequestTimeout(500.millis) {
      val user: Future[Option[User]] = DataAccess.lookupUser(name)
      onComplete(user) {
        case Success(Some(u)) => complete(u)
        case Success(None)    => complete(NotFound)
        case Failure(t)       => complete(InternalServerError, t.getMessage)
      }
    }
}
```

---
class: centre, middle
#  Responsiveness under load

???
- Eyup

---
# Playing fair

```




                                                   +-----------+
                                                   |           |
                                             +---->| Database  |
                                             |     |           |
                                             |     +-----------+
                                             |
   +---------+                   +----------+
   |         | +---------------> |          |
   | Client  |                   | Server   |
   |         | <---------------+ |          |
   +---------+                   +----------+
                                             |
                                             |
                                             |
                                             |       +------------+
                                             |       |            |
                                             +------+|  Service   |
                                                     |            |
                                                     +------------+
```

---
# The default

.center[![queue](toomuchmail.jpg)]

---
# Queueing and/or buffering

* How would this work if Kafka was between the services?

<br/>
<br/>

.center[![queue](pubsub-half.png)]

---
# Fast publisher

* Down stream gets overwhelmed
* Publisher has wasted resources

<br/>
<br/>

.center[![queue](pubsub-full.png)]

<br/>
<br/>

* Would this work in memory?
* Why produce data no one is ready to consume?

---
# Fast subscriber
* Underutilized subscriber
* Publisher happy

<br/>
<br/>

.center[![queue](pubsub-empty.png)]

---
# Reacting to failure
* Is the consumer slow or down?
* Circuit breakers

<br/>
<br/>
.center[![Circuit breaker](circuit-breaker.png)]


???

- Circuit breakers
- Throttling

---
# Flow control

* Dynamically adjust the rate based on demand

<br/>
<br/>
.center[![queue](demand.png)]

???

---
# TCP flow control

???
- Gets some pics

---
# Reactive streams

---
# Akka HTTP

```scala
// TODO example
```

---
class: centre, middle
# Scalability

---
class: centre, middle
# Resource efficiency

---
# Summary

---
class: center, middle

# Thanks!
Code and slides at `chbatey/akka-streams-examples` on GitHub

## Questions?






 </textarea>
<script src="remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create();
</script>
</body>
</html>
